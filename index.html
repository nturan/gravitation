<!DOCTYPE html>
<html ng-app="gravitationApp">
<head>
    <title>Gravitation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.9/angular.min.js"></script>
    <script src="Body.js"></script>
    <script src="Ephemeris.js"></script>
    <script src="three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="Gravity.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }

        #menu {
            top: 10px;
            right: 10px;
        }

        #bodies-list {
            bottom: 10px;
            right: 10px;
        }

        .gui {
            padding: 10px;
            position: absolute;
            color: white;
            opacity: 0.2;
            transition: opacity 0.3s ease-in-out;
        }

        .gui:hover {
            opacity: 1;
            transition: none;
        }

        .row {
            margin-bottom: 10px;
        }

        .vector input {
            width: 50px;
        }

        td {
            padding: 5px;
        }

        tbody tr:hover {
            background-color: gray;
            cursor: pointer;
        }
    </style>
</head>
<body ng-controller="MainController as main">


<div id="creationOptions" class="gui" ng-show="main.creation">
  <div class ="row">
    <label>
      Name: <input type="text" ng-model="main.newName" placeholder="Name">
    </label>
    <label>
      Mass: <input type="text" ng-model="main.newMass" placeholder="Mass">
       in 10^23 kg
    </label>
  </div>
<div class ="row">
    <label>
      Radius: <input type="text" ng-model="main.newRadius" placeholder="Radius"> in km
    </label>
    <label>
      Start velocity: {{main.newVelocity}}
       in AU/year
    </label>
  </div>
</div>
<div id="menu" class="gui">
    <div class='row'>
        <label>
            <input type="checkbox" ng-model="main.showAxes" ng-change="main.toggleAxes()">
            Toggle Axes
        </label>
        <label>
            <input type="checkbox" ng-model="main.showGrid" ng-change="main.toggleGrid()">
            Show ecliptic plane
        </label>
    </div>
    <div class='row'>
        <label>
            <input type="checkbox" ng-model="main.showTraj" ng-change="main.toggleTraj()">
            Toggle trajectories
        </label>
    </div>
    <div class='row'>
        <button ng-click="main.resetCamera()">Reset Camera</button>
        <button ng-click="main.createBody()">Create Body</button>
        <button ng-click="main.togglePause()">Pause Simulation</button>
    </div>
    <div class='row'>
      <label>{{frameRate}} Frames per Second</label>
    </div>
    <div class='row'>
      <label>Simulation Speed</label>
      <select ng-model="main.simSpeed" 
              ng-options="option.name for option in main.availableSpeeds">
      </select>
    </div>
</div>

<div id="bodies-list" class="gui">
    <button ng-click="main.toggleBodiesList()">Toggle List</button>
    <div ng-show="main.bodiesListShown">
        <table>
            <thead>
            <tr>
                <th>Name</th>
                <th>Mass</th>
                <th>Radius</th>
                <th>Position (x,y,z)</th>
                <th>Velocity (x,y,z)</th>
                <th>Acceleration (x, y, z)</th>
                <th>Color</th>
                <th></th>
            </tr>
            </thead>
            <tbody>
            <tr ng-repeat="body in main.bodies" ng-click="main.track(body)">
                <td>{{body.name}}</td>
                <td>{{body.mass}}</td>
                <td>{{body.radius}}</td>
                <td>({{body.formatPosition()}})</td>
                <td>({{body.formatVelocity()}})</td>
                <td>({{body.formatAcceleration()}})</td>
                <td><span style="color: #{{body.color.toString(16)}}">#{{body.color.toString(16)}}</span></td>
                <td>
                    <button ng-click="main.remove(body)">Remove</button>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
</div>
  
<script type="text/javascript">
    angular.module('gravitationApp', [])
        .controller('MainController', function ($scope) {
            let main = this;
            let scene, camera, renderer, controls;
            main.availableSpeeds = [{physLoop: 1,  stepSize: 1/365/30/24/60, name: "minutes per second"},
                                    {physLoop: 60, stepSize: 1/365/30/24/60, name: "hours per second"},
                                    {physLoop: 24, stepSize: 1/365/30/24,    name: "days per second"},
                                    {physLoop: 7,  stepSize: 1/365/30,       name: "weeks per second"},
                                    {physLoop: 30, stepSize: 1/365/30,       name: "months per second"},
                                    {physLoop: 52, stepSize: 7/365/30,       name: "years per second"}];
      //control variables
            var dragStart = new THREE.Vector3();
            var dragEnd = new THREE.Vector3();
            var dragVector = new THREE.Vector3();
            let mouseDrag = false;
            let pauseSim = false;
            main.bodiesListShown = false;
            let mouse = new THREE.Vector2();
      //time control variables
            let startCounter = new Date().getTime();
            let frmTime = startCounter;
            let phsStart = startCounter;
            let phsTime = startCounter;
            let phsTicksPerSecond = 30;
            let phsCycle = 1000/phsTicksPerSecond;
            let frmCounter = 0;
            let trajLength = 100;//just array length, calculating real time too complicated
            let trajUpdateCounter = 0;
            let trajUpdateFreq = 1; // phys Ticks

      // creation plane
            let plgeometry = new THREE.PlaneGeometry(100000, 100000);
            let plmaterial = new THREE.MeshBasicMaterial({color: 0xffff00, side: THREE.DoubleSide});
            let planeZ = new THREE.Mesh(plgeometry, plmaterial);
      // newBody
            let nBgeometry = new THREE.IcosahedronGeometry(3, 2);
            let nBmaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                emissive: 0x072534,
                side: THREE.DoubleSide,
                shading: THREE.FlatShading
            });
            let newBody = new THREE.Mesh(nBgeometry, nBmaterial);
            newBody.name = "newCreation";
      
      //axis
            let axisHelper = new THREE.AxesHelper(500);
            axisHelper.name = "AxisHelper";

            this.toggleAxes = function () {
                if (main.showAxes)
                    scene.add(axisHelper);
                else
                    scene.remove(axisHelper);
            };
            
            let gridHelper = new THREE.PolarGridHelper(5000, 50, 10, 50);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.name = "PolarGrid";

            // Show / Hide Ecliptic Plane
            main.toggleGrid = function () {
                if (main.showGrid)
                    scene.add(gridHelper);
                else
                    scene.remove(gridHelper);
            };
      
      
            main.toggleBodiesList = function () {
                main.bodiesListShown = !main.bodiesListShown;
            }
            
            main.toggleTraj = function(){
                if(!main.showTraj){
                  for(let i in main.bodies){
                    let body = main.bodies[i];
                    scene.remove(body.trajObj);
                    body.traj = [];
                  }
                }
            }
           
            
            //later i will need to remove and add all trajectories in scene
//             main.toggleTraj = function () {
//                 main.showTraj = !main.showTraj;
//             }

            main.resetCamera = function () {
                controls.reset();
            };

            main.createBody = function () {
              if(main.creation){
                main.creation = false;
                pauseSim = false;
                scene.remove(newBody);
              }else{
                main.creation = true;
                pauseSim = true;
                newBody.position = new THREE.Vector3(0, 0, 0);
                scene.add(newBody);
              }
            };
      
            this.togglePause = function () {
                if (pauseSim && !main.creation)
                    pauseSim = false;
                else
                    pauseSim = true;
            };



            main.newName = 'New';
            main.newMass = 1;
            main.newRadius = 1;
            main.newPositionX = 1;
            main.newPositionY = 0;
            main.newPositionZ = 0;
            main.newVelocityX = 0;
            main.newVelocityY = 5;
            main.newVelocityZ = 0;
            main.newAcceleration = 0;
            main.newColor = 'ffffff';


//             main.bodies = [
//                 new Body("Sun", 1.988544E+7, 695700, [ 1.488845024691211E-03,  6.381654552143589E-03, -1.126420425735407E-04],
//                          [-6.208736136983524E-06,  4.640963331504805E-06,  1.483206369475573E-07], 0, 0xffff33),
//                 new Body("Mercur", 3.302, 2440, [ 3.614665888277512E-01, -7.759810595975869E-02, -3.999904486712141E-02],
//                          [9.302724436347369E-04,  2.866514843996328E-02,  2.256175303870725E-03], 0),
//                 new Body("Venus", 48.685, 6052, [ 7.264945036351604E-01, -1.957121171107659E-02, -4.230613854738632E-02],
//                          [6.278768987279022E-04,  2.012552105537308E-02,  2.395645034105181E-04], 0),
//                 new Body("Earth", 59.7219, 6371, [-8.803257898433657E-01,  4.545130073016067E-01, -1.251704673020013E-04],
//                          [-8.075306082562402E-03, -1.540171441572302E-02,  7.885144556138575E-07], 0, 0x3333ff),
//                 new Body("Moon", 734.9E-3, 1737, [-8.785755476608252E-01, 4.563201901680939E-01,-3.570130251523075E-04],
//                          [-8.521922410260499E-03,-1.500283383979852E-02, 4.311910684926032E-06], 0),
//                 new Body("Mars", 6.4185, 3390, [-1.239873336202447E+00, -9.703030342552387E-01,  9.886664338815770E-03],
//                          [9.171402633791702E-03, -9.796767140104022E-03, -4.304586786898006E-04], 0, 0xff3333),
//                 new Body("Jupiter", 18981.3, 69911, [-4.010558503618121E+00, -3.641925022005197E+00,  1.048122707815689E-01],
//                          [4.983260657384969E-03, -5.227190479466572E-03, -8.978151110962477E-05], 0)];
            main.bodies = Ephemeris.bodies;
            main.add = function () {
                let color = parseInt('0x' + main.newColor);
                let body = new Body(main.newName, main.newMass, main.newRadius, [main.newPositionX, main.newPositionY, main.newPositionX], [main.newVelocityX, main.newVelocityY, main.newVelocityZ], main.newAcceleration, color);
                main.bodies.push(body);
                addToScene(body);
            };

            main.remove = function (body) {
                let i = main.bodies.indexOf(body);
                scene.remove(body.mesh);
                main.bodies.splice(i, 1);
            };

            function addToScene(body) {
                let geometry = new THREE.IcosahedronGeometry(body.radius, 2);
                let material = new THREE.MeshPhongMaterial({
                    color: body.color,
                    emissive: 0x072534,
                    side: THREE.DoubleSide
                });
                body.mesh = new THREE.Object3D();
                // just for white lines on a body. could be just body.mesh = new THREE.Mesh(geometry, material);
                body.mesh.add(new THREE.LineSegments(new THREE.WireframeGeometry(geometry),
                                                     new THREE.LineBasicMaterial({color: 0xffffff,
                                                                                  transparent: true,
                                                                                  opacity: 0.5})));
                body.mesh.add(new THREE.Mesh(geometry, material));
                
                body.mesh.name = body.name;
                scene.add(body.mesh);

                let coord = transformInScreenCoord(body.position);
                body.mesh.position = new THREE.Vector3(coord.x, coord.y, coord.z);
            }

            main.track = function (body) {
                main.tracking = body;
            };

            init();
            animate();

            function init() {

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.001, 100000);
                camera.position.set(500, -500, 500);
                
                main.simSpeed = main.availableSpeeds[3];
                camera.up.set( 0, 0, 1 );
                for (let i in main.bodies) {
                    addToScene(main.bodies[i])
                }

                //Lights
                let light1 = new THREE.PointLight(0xffaaaa, 2, 0, 0);

                light1.position.set(0, 0, 0);
                // light1.color.setHSL( 0.55, 0.9, 0.5 );
                scene.add(light1);

                let light2 = new THREE.AmbientLight(0x333333);
                scene.add(light2);

                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(window.innerWidth, window.innerHeight);

                document.body.appendChild(renderer.domElement);

                //Ich wuerde unsere eigene Control Funktion schreiben. Das ist unhandlich
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 1;
                // controls.enableZoom = true;
                main.tracking = null;

            }

            function animate(apply) {
                requestAnimationFrame(animate);
                              //fps counter
                frmTime = new Date().getTime();
                phsTime = frmTime;
                if (frmTime - startCounter >= 1000){
                  startCounter = new Date().getTime();
                  $scope.$apply();
                  $scope.frameRate = frmCounter;
                  frmCounter = 0;
                }else{
                  frmCounter++;
                }
                
                if(phsTime - phsStart>= phsCycle && !pauseSim){
                  phsStart = new Date().getTime();
                  physicsTick();
                }


                if (main.tracking) {
                    let pos = main.tracking.mesh.position;
//                     camera.position.set(pos.x+100, pos.y+100, pos.z+100);
                    controls.target = new THREE.Vector3(pos.x, pos.y, pos.z);
//                     gridHelper.position.x = pos.x;
//                     gridHelper.position.y = pos.y;
                    controls.update();
                }
                if (main.creation && !main.mouseDrag) {
                    newBody.position.x = pickVector3FromScene(planeZ, mouse, camera).x;
                    newBody.position.y = pickVector3FromScene(planeZ, mouse, camera).y;
                    newBody.position.z = pickVector3FromScene(planeZ, mouse, camera).z;
                    controls.enabled = false;
                    controls.update();
                } else if( main.creation && main.mouseDrag ){
                    dragEnd = pickVector3FromScene( planeZ, mouse, camera );
                    dragVector = dragEnd.sub( dragStart );
                    main.newVelocity = Gravity.magnitudeVec3([dragVector.x/10,
                                                              dragVector.y/10,
                                                              dragVector.z/10]);
                    $scope.$apply();
                    controls.enabled = false;
                    controls.update();
                } else {
                    controls.enabled = true;
                    controls.update();
                }
                
                distantObjectIndication();
                if (main.bodiesListShown && apply)
                    $scope.$apply();
                renderer.render(scene, camera);
            }

      
            function distantObjectIndication(){
              for (let i in main.bodies){
                let body = main.bodies[i];
                let coord = transformInScreenCoord(body.position);
                let distVec = [coord.x - camera.position.x,
                               coord.y - camera.position.y,
                               coord.z - camera.position.z];
                let distMag = Gravity.magnitudeVec3(distVec);
                let scaleFaktor = 2/body.mesh.children[1].geometry.parameters.radius;
                if (distMag>100){
                  body.mesh.scale.set(scaleFaktor, scaleFaktor, scaleFaktor);
                }else if (distMag > 30 && body.name != "Sun"){
                  body.mesh.scale.set(scaleFaktor/10, scaleFaktor/10, scaleFaktor/10);
                }else {
                  body.mesh.scale.set(1, 1, 1);
                }
              }
            }

            function updateTraj(){
              for (let i in main.bodies){
                let body = main.bodies[i];
                let traj = body.traj;
                let coord = transformInScreenCoord(body.position);
                traj.push(new THREE.Vector3(coord.x, coord.y, coord.z ));
                
                if(traj.length > trajLength){
                  traj.shift();    
                }
                if(traj.length > 3){
                  let trajCurve = new THREE.CatmullRomCurve3( traj );
                  var trajPoints = trajCurve.getPoints( trajLength );
                  var trajGeometry = new THREE.BufferGeometry().setFromPoints( trajPoints );
                  var trajMaterial = new THREE.LineBasicMaterial( {color: 0xffffff} );
                  let trajObj = body.trajObj;
                  scene.remove(trajObj);
                  trajObj = new THREE.Line( trajGeometry, trajMaterial );
                  scene.add(trajObj);
                  body.trajObj = trajObj;
                }
                body.traj = traj;
              }
            }
      
      
      
      
            function physicsTick(){
                Gravity.step = main.simSpeed.stepSize;
                if(main.showTraj){
                   if(trajUpdateCounter > trajUpdateFreq){
                     updateTraj();
                     trajUpdateCounter = 0;
                   }else{
                     trajUpdateCounter++;
                   }
                }
                for (let k=0; k<main.simSpeed.physLoop; k++){
                  Gravity.calculateGravity(main.bodies);
                  for (let i in main.bodies) {
                      let body = main.bodies[i];

                      if (!body.toDestroy) {
                          let mesh = body.mesh;
                          let coord = transformInScreenCoord(body.position);
                          mesh.position.x = coord.x;
                          mesh.position.y = coord.y;
                          mesh.position.z = coord.z;
                      } else {
                          main.remove(body);
                      }
                  }
                }
                
            }
            
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mouseup', onMouseUp, false);

            function onMouseDown(event) {

                switch (event.button) {
                    case 0:
                          let raycaster = new THREE.Raycaster();
                          raycaster.setFromCamera( mouse, camera );
                          for (let i in main.bodies) {
                              let body = main.bodies[i];
                              let intersect = raycaster.intersectObject(body.mesh.children[1]);
                              if (intersect.length > 0) {
                                  main.track(body);
                                  return;
                              }
                          }
                        break;
                    case 1:
                        break;
                    case 2:
                        if (main.creation) {
                            main.mouseDrag = true;
                            dragStart = pickVector3FromScene(planeZ, mouse, camera);
                        }else{
                          main.tracking = null;
                          gridHelper.position.x = 0;
                          gridHelper.position.y = 0;
                        }
                        break;
                }
            }

            function onMouseMove(event) {
                // calculate mouse position in normalized device coordinates
                // (-1 to +1) for both components
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = -( event.clientY / window.innerHeight ) * 2 + 1;
            }

            function onMouseUp( event ){
              switch ( event.button ){
                case 0:
                  break;
                case 1:
                  break;
                case 2:
                  main.mouseDrag = false;
                  if(main.creation){
                    main.creation = false;
                    pauseSim = false;
                    let newPlanet = new Body(main.newName, main.newMass, main.newRadius,
                        [newBody.position.x / 100, newBody.position.y / 100, newBody.position.z / 100],
                        [dragVector.x / 3652.5, dragVector.y / 3652.5, dragVector.z / 3652.5], 0, newBody.material.color);
                    main.bodies.push(newPlanet);
                    addToScene(newPlanet);
                    scene.remove(newBody);
                  }
                  break;
              }
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
           

        });
  
        function pickVector3FromScene(plane, mouse, camera) {

                //todo: check whether the mouse on plane

                // update the picking ray with the camera and mouse position
                
                let raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);

                // calculate objects intersecting the picking ray
                let intersect = raycaster.intersectObject(plane);
                return intersect[0].point;
        }
  
        function transformInScreenCoord(r) {
            return {x: r[0] * 100, y: r[1] * 100, z: r[2] * 100};
        }
</script>
</body>
</html>
